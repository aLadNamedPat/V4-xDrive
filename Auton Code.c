#pragma config(Sensor, in2,    Yaw ,           sensorGyro)
#pragma config(Motor,  port4,           leftFront,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           rightFront,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           leftBack,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           rightBack,     tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float kP = 0;
float kI = 0;
float kD = 0;

void GyroPointTurn (float degrees) {
	if (degrees < 0){
		float gyroTarget = degrees; 
		SensorValue[gyroPort] = 0;
		bool running = true;
		float previous_error = 0;
		float Integral = 0;
		while(running){
			float current_Gyro_Value = SensorValue[Yaw];
			previous_error = error;
			float error = gyroTarget - current_Gyro_Value;
			float Derivative = error - previous_error;
			Integral  += error;
			
			float motorPower = (kP * error + kI * Integral + kD * Derivate);
			motor[leftFront] = -motorPower;
			motor[rightFront] = -motorPower;
			motor[leftBack] = -motorPower;
			motor[rightBack] = -motorPower;
	}
	float gyroTarget = degrees; 
	SensorValue[gyroPort] = 0;
	bool running = true;
	float previous_error = 0;
	float Integral = 0;
	while(running){
		float current_Gyro_Value = SensorValue[Yaw];
		previous_error = error;
		float error = gyroTarget - current_Gyro_Value;
		float Derivative = error - previous_error;
		Integral  += error;
		
		float motorPower = (kP * error + kI * Integral + kD * Derivate);
		motor[leftFront] = motorPower;
		motor[rightFront] = motorPower;
		motor[leftBack] = motorPower;
		motor[rightBack] = motorPower;
	}
}

void Strafe(float degrees, float speed = 1,float time = 0)
{
	float radians = degreesToRadians(degrees);
	float converted_radians = (radians - PI / 4);
// Change motor power based on power
// X power for robot
	float motorXspeed = speed * cos(converted_radians);
	float motorYspeed = speed * sin(converted_radians);

	motor[leftFront] = motorXspeed;
	motor[rightFront] = motorYspeed;
	motor[leftBack] =  -motorYspeed;
	motor[rightBack] = -motorXspeed;
	wait1Msec(time);

task main()
{
Strafe((50), 50, 1000);
GyroPointTurn(30);
}
