#pragma config(Sensor, in2,    Yaw,            sensorGyro)
#pragma config(Motor,  port4,           leftFront,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           rightFront,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           leftBack,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           rightBack,     tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
void PIDstrafe(float kP, float kI, float kD, float time, float degrees, float speed){
	SensorType[in4] = sensorNone;
	SensorType[in4] = sensorGyro;
	SensorScale[in4] = 1275;
	wait1Msec(1000);
	float radians = degreesToRadians(degrees);
	float converted_radians = (radians - PI / 4);

	float current_error = SensorValue[in4];
	float last_error = 0;

	float proportional;
	float derivative;
	float integral;
	float motorSpeed;
	clearTimer(timer1);

	while(time1[timer1] < time){
		current_error = SensorValue[in4];
		proportional = current_error;
		derivative = current_error - last_error;
		last_error = current_error;
		integral += current_error;
		displayNextLCDNumber(current_error);
		motorSpeed = (kP * proportional) + (kD * derivative);
		float motorXspeed = (speed) * cos(converted_radians) + motorSpeed;
		float motorYspeed = (speed) * sin(converted_radians) - motorSpeed;

		motor[leftFront] = motorXspeed;
		motor[rightFront] = motorYspeed;
		motor[leftBack] =  motorYspeed;
		motor[rightBack] = motorXspeed;
		clearLCDLine(0);
	}
	motor[leftFront] = 0;
	motor[rightFront] = 0;
	motor[leftBack] =  0;
	motor[rightBack] = 0;
}

void gyroRegularTurn(float degrees){
	bool whileLoop = true;
	float Sensor;
	if (degrees <= 0){
		while(whileLoop){
			motor [leftFront] = -20;
			motor[rightFront] = -20;
			motor[leftBack] = 20;
			motor[rightBack] = 20;
			Sensor = SensorValue[in4];
			displayNextLCDNumber(Sensor);
			clearLCDLine(0);
			if (Sensor >= degrees)
				{
				whileLoop = false;
				}
		}
	}
	if (degrees > 0){
		while(whileLoop){
			motor [leftFront] = 20;
			motor[rightFront] = 20;
			motor[leftBack] = -20;
			motor[rightBack] = -20;
			Sensor = SensorValue[in4];
			displayNextLCDNumber(Sensor);
			clearLCDLine(0);
			if (Sensor <= degrees)
				{
				whileLoop = false;
				}
		}
	}
	motor [leftFront] = 0;
	motor[rightFront] = 0;
	motor[leftBack] =  0;
	motor[rightBack] = 0;
}

void gyroReset(){
	wait1Msec(1000);
	SensorType[in4] = sensorNone;
	SensorType[in4] = sensorGyro;
	SensorScale[in4] = 1050;
	wait1Msec(1000);
}

void timeStrafe(float degrees, float speed = 100,float time = 1000) {
	float radians = degreesToRadians(degrees);
	float converted_radians = (radians - PI / 4);
// Change motor power based on power
// X power for robot
	float motorXspeed = speed * cos(converted_radians);
	float motorYspeed = speed * sin(converted_radians);

	motor[leftFront] = motorXspeed;
	motor[rightFront] = motorYspeed;
	motor[leftBack] =  motorYspeed;
	motor[rightBack] = motorXspeed;
	wait1Msec(time);
}

// void PIDStrafe (float degrees, float speed, float time);{
//	bool Running = true;
//	while(Running){

//	}
//}

void turn(float speed, float time) {
	motor[leftFront] = speed;
	motor[rightFront] = speed;
	motor[leftBack] = -speed;
	motor[rightBack] = -speed;
	wait1Msec(time);
}
void Stop(float time) {
	motor[leftFront] = 0;
	motor[rightFront] = 0;
	motor[leftBack] =  0;
	motor[rightBack] = 0;
	wait1Msec(time);
}

task main()
{
//90 degrees is 90 degrees to the right of the front side
//wait1Msec(1000);

timeStrafe(90, 127, 1800);
Stop(1000);
timeStrafe(90, 127, 2350);
Stop(1000);
timeStrafe(90, 127, 3000);
Stop(1000);
timeStrafe(0, 127, 6300);
//turn(-20, 200);
Stop(1000);
timeStrafe(270, 127, 2500);
Stop(1000);
timeStrafe(270, 127, 5200);
Stop(1000);
timeStrafe(132, 127, 12000);
Stop(1000);
}

