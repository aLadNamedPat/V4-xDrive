#pragma config(Sensor, in4,    Gyro,           sensorGyro)
#pragma config(Motor,  port4,           leftFront,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           rightFront,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           leftBack,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           rightBack,     tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void PIDstrafe(float kP, float kI, float kD, float time, float degrees, float speed){
	SensorType[in4] = sensorNone;
	SensorType[in4] = sensorGyro;
	SensorScale[in4] = 1275;
	float radians = degreesToRadians(degrees);
	float converted_radians = (radians - PI / 4);

	float current_error = SensorValue[in4];
	float last_error = 0;

	float proportional;
	float derivative;
	float integral;
	float motorSpeed;
	clearTimer(timer1);

	while(time1[timer1] < time){
		current_error = SensorValue[in4];
		proportional = current_error;
		derivative = current_error - last_error;
		last_error = current_error;
		integral += current_error;
		displayNextLCDNumber(current_error);
		motorSpeed = (kP * proportional) + (kD * derivative);
		float motorXspeed = (speed) * cos(converted_radians) + motorSpeed;
		float motorYspeed = (speed) * sin(converted_radians) + motorSpeed;

		motor[leftFront] = motorXspeed;
		motor[rightFront] = motorYspeed;
		motor[leftBack] =  motorYspeed;
		motor[rightBack] = motorXspeed;
		clearLCDLine(0);
	}
	motor[leftFront] = 0;
	motor[rightFront] = 0;
	motor[leftBack] =  0;
	motor[rightBack] = 0;
}
task main()
{
PIDstrafe(0.1, 0.03, 0.03, 10000, 0, 50);
}
